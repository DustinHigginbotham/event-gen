// Code generated by event-source-gen. DO NOT EDIT.
package app

import (
	"context"
	"fmt"
)

type App struct {
	store Store
	queue EventQueue
	registry *Registry
	quit chan struct{}

	{{- range .Domains}}
	{{.Entity.Name | toLower}} *{{.Entity.Name | toExported}}Service
	{{- end}}
}

func NewApp(
	store Store,
	queue EventQueue,
	registry *Registry,
) *App {
	a := &App{
		store: store,
		queue: queue,
		registry: registry,
		quit: make(chan struct{}, 1),
	}

	a.registerEvents()

	return a
}

func (a *App) Close() {
	a.quit <- struct{}{}
}

func (a *App) Start(ctx context.Context) {
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}

	a.startReactors(ctx)
	a.startProjections(ctx)
	go q.Start(ctx)
}

func (a *App) startReactors(ctx context.Context) {

	{{- if HasReactors .Domains}}
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}
	{{- else }}
	// no reactors
	{{- end }}

	{{- range .Domains}}
	{{$entity := .Entity}}
	{{- if .Reactors}}
	if c, ok := a.{{$entity.Name | toLower}}.manager.({{$entity.Name}}ReactorManager); ok {
	{{- range .Reactors}}{{- if eq .Type "local" }}
		a.registerReactor(ctx, q, "{{.ReactsTo | toLower}}", func(ctx context.Context, app *App, eventType string, event Eventer) {
			c.Handle{{.Name}}(ctx, app, event.(*{{.ActualEvent}}))
		})
	
	{{- end}}{{- end}}
	}
	{{- end}}
	{{- end}}
}

func (a *App) startProjections(ctx context.Context) {
	var q EventQueuePull
	var ok bool
	if q, ok = a.queue.(EventQueuePull); !ok {
		return
	}

	{{- range .Domains}}
	{{$entity := .Entity}}
	{{$events := .Events}}
	{{- if .Projections}}
	if c, ok := a.{{$entity.Name | toLower}}.manager.({{$entity.Name}}ProjectionManager); ok {
	{{- range .Projections}}{{- range .ReactsTo}}
	
		a.registerReactor(ctx, q, "{{. | toLower}}", func(ctx context.Context, app *App, eventType string, event Eventer) {
			c.Handle{{index $.EventMap .}}Projection(ctx, a, event.(*{{index $.EventMap .}}))
		})

	
	{{- end}}{{- end}}
	}
	{{- end}}
	{{- end}}
}

func (a *App) Store() Store {
	return a.store
}

func (a *App) Queue() EventQueue {
	return a.queue
}

func (a *App) Registry() *Registry {
	return a.registry
}

func (a *App) registerEvents() {
	{{- range .Domains}}
	a.registry.Add({{.Name | toLower}}Events...)
	{{- end}}
}

func (a *App) registerReactor(
	ctx context.Context,
	q EventQueuePull,
	eventType string,
	reactor func(ctx context.Context, app *App, eventType string, event Eventer),
) {
	q.Subscribe(ctx, func(ctx context.Context, event Eventer) error {
		if event.GetType() == eventType {
			reactor(ctx, a, event.GetType(), event)
		}
		return nil
	})
}

func (a *App) registerProjections(
	ctx context.Context,
	q EventQueuePull,
	reactor func(ctx context.Context, app *App, eventType string, event Eventer),
) {
	q.Subscribe(ctx, func(ctx context.Context, event Eventer) error {
		reactor(ctx, a, event.GetType(), event)
		return nil
	})
}

func (a *App) SaveAndPublish(ctx context.Context, id string, event Eventer) error {
	if err := a.store.Save(ctx, id, event); err != nil {
		return fmt.Errorf("failed to save event: %w", err)
	}

	a.queue.Publish(ctx, event)

	return nil
}

{{- range .Domains}}
func (a *App) {{.Entity.Name}}() *{{.Entity.Name | toExported}}Service {
	return a.{{.Entity.Name | toLower}}
}

func (a *App) Get{{.Entity.Name | toExported}}ByID(ctx context.Context, id string) (*{{.Entity.Name}}, error) {
	events, err := a.store.Get(ctx, id)
	if err != nil {
		return nil, err
	}

	if len(events) == 0 {
		return nil, fmt.Errorf("not events found for %s", id)
	}

	builder := &{{.Entity.Name}}Builder{
		Manager: a.{{.Entity.Name | toLower}}.manager.({{.Entity.Name}}EventManager),
	}

	return builder.Rebuild(events), nil
}
{{- end}}


func GetUserFromContext[T any](ctx context.Context) (T, error) {
	var u T
	var ok bool

	if u, ok = ctx.Value("user").(T); ok {
		return u, nil
	}

	return u, fmt.Errorf("user not found in context")
}